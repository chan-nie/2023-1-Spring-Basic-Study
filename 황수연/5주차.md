# 섹션 6. 스프링 DB 접근 기술

## H2 데이터베이스 설치

- 개발이나 테스트 용도로 가볍고 편리한 DB. 웹 화면 제공, 교육용.
- 실무에서는 보통 DB로 MySQL, Oracle을 많이 사용함.
    - 그중에서도 특히 MySQL계열의 DB를 많이 사용함.
- 설치 - h2 데이터베이스 버전을 스프링 부트 버전에 맞추기 - (bin 파일에서)권한 주기 `chmod 755 h2` - 실행 `./h2.sh`
    - 가끔 실행이 안될 때가 있는데, 이때는 ip주소 자리에 `localhost` 로 고치고 실행
    - JDBC URL의 값으로 `jdbc:h2:~/test` 라고 되어있는데 이는 경로임
- 데이터베이스 파일 생성 방법 - `jdbc:h2:~test` (최초 한 번)
- 연결 끊고 `~/test.mv.db` 파일 생성 확인
- 이후부터는 JDBC URL 에 `jdbc:h2:tcp://localhost/~/test` 를 입력해서 접속

### 테이블 생성하기

- MEMBER 테이블 생성
    - `id` - DB에서는 `Long`타입이 아니라 `bigint` 형임
        - `generated by default as identity` -  `null` 값, 즉 값을 세팅하지 않고 `insert`하면 DB가 알아서 자동으로 값을 채워줌.

```sql
create table member
(
	id bigint generated by default as identity,
	name varchar(255),
	primary key(id)
);
```

- 이후부터는 `select * from member;`  를 통해 조회 가능
- `insert into member(name) values(’spring’);`  
- 프로젝트 내에 `sql` 폴더를 만들고 `ddl.sql` 폴더를 만들어서 sql문 관리..?

## 순수 JDBC

- JDBC는 DB SQL을 통해 어플리케이션 서버와 DB를 연결하기 위한 기술임.
    - 20년 전에 개발자들이 개발하던 방법인 순수 JDBC

### 환경 설정

**build.gradle 파일에 jdbc, h2 데이터베이스 관련 라이브러리 추가**

- 자바는 DB와 붙으려면 기본적으로 jdbc 드라이버가 있어야 함.
- DB가 제공하는 클라이언트가 필요한데, 이것이 h2 database 임을 명시

```groovy
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'
```

**스프링 부트 데이터베이스 연결 설정 추가**

`resources/application.properties`

- DB와 붙으려면 접속 정보도 필요함 - 경로만 넣으면 스프링 부트가 다 해줌.
    - [https://www.inflearn.com/questions/94189/wrong-user-name-or-password](https://www.inflearn.com/questions/94189/wrong-user-name-or-password)

```groovy
spring.datasource.url = jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name = org.h2.Driver
spring.datasource.username=sa  // 추가로 스프링 부트 버전 업데이트에 의해 이 코드도 넣어줘야 함.
```

### Jdbc 리포지토리 구현

- `interface`로 `MemberRepository`를 만들었기때문에 이것의 구현체를 만들면 됨.
    - 새로 `JdbcMemberRepository.java` 만들기
    - 회원을 저장하는 역할은 MemberRepository가 하지만, 구현을 메모리로 할지 jdbc로 할지에 차이가 있는 것임.
- DB에 붙으려면 DataSource라는 것이 필요함! → `private final DataSource dataSource;`
    - 그리고 이것을 나중에 스프링에게서 주입받아야 함.

```java
// 이건 pseudo code 일 뿐.
String sql = "insert into member(name) values(?)";

Connection connection = dataSource.getConnection();  // DB connection을 받아오기

PreparedStatement pstmt = connection.prepareStatement(sql);  // 문장 작성
pstmt.setString(1, member.getName());
pstmt.executeUpdate();  // 여기까지 하면 DB에 쿼리가 날라감.
```

### 스프링 설정 변경

- SpringConfig 파일에서는 `MemoryMemberRepository()`를 스프링 빈으로 등록하고 있음.
    
    ⇒ 이것을 `JdbcMemberRepository()` 로 바꿔야 함
    
    - 그리고 이때 `DataSource`를 주입해줘야 하는데, 스프링이 제공해줌.
        - `DataSource` 변수 생성 시 `@Autowired`로 달아줘도 되고, `private`으로선언만 하고 생성자를 생성해서 `@Autowired` 달아줘도 됨.
    - DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체. 스프링부트는 데이터베이스 커넥션 정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어둠 → 따라서 DI를 받을 수 있음.

⇒ 스프링 사용 이유..

→ 객체 지향적인 설계가 좋은 이유는 다형성을 잘 활용할 수 있기 때문. 인터페이스를 만들어두고 구현체는 바꿔끼우기를 할 수 있음. 스프링은 이를 더 편리하게 사용할 수 있도록 스프링 컨테이너가 이를 지원해주는 것임. 의존성 주입덕분에 더 편리하게 사용할 수 있음.

- **개방-폐쇄 원칙(OCP, Open-Closed Principle)**
    - 확장에는 열려 있고, 수정(변경)에는 닫혀 있다.
    - 객체 지향에서 말하는 다형성이라는 개념을 잘 활용하면 기능을 완전히 변경해도(memory→ jdbc), 어플리케이션 전체를 수정할 필요가 없어짐. (조립하는 코드는 수정해야 하지만)
- 스프링의 DI를 사용하면 **기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경**할 수 있음.

## 스프링 통합 테스트

- 스프링 컨테이너와 DB까지 연결한 통합 테스트 진행 - MemberServiceIntegrationTest 생성
    - `@SpringBootTest` → 스프링 컨테이너와 테스트를 함께 실행
    - `@Transactional` → 이 두 어노테이션 적어줘야 함.
        - 데이터베이스에는 트랜잭션이라는 개념이 있음. DB에 insert 쿼리를 한 다음에 커밋이라는 것을 해주어야 DB에 반영됨.
        - 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백함 → DB에 데이터가 반영 안됨. ⇒ `@Transactional`의 기능
        - 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않음.
    - 이전까지는 직접 객체를 생성해서 넣었는데, 이제는 스프링 컨테이너에게 MemberService, MemberRepository를 달라고 요청하면 됨. ⇒ 생성자로 DI했던 것..
    - 테스트는 제일 끝단에 있는 것이기 때문에 제일 편한 방법(`@Autowired` 사용, 필드 기반)을 사용하면 됨

## 스프링 JdbcTemplate

- 순수 JDBC로는 개발하기 힘들기 때문에 스프링이 제공하게 된 중복을 제거한 JdbcTemplate 이라는 기술 → 어플리케이션에서 데이터베이스로 SQL을 편리하게 날릴 수 있음.
- 순수 JDBC와 동일한 환경설정 하면 됨.
- 스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해줌. 하지만 SQL은 직접 작성해야 함.
- 실무에서도 많이 사용하는 라이브러리!

**스프링 JdbcTemplate 회원 리포지토리**

- `JdbcTemplate`이 이미 있음. 그러나 주입받을 수는 없음. → 먼저 `DataSource`가 필요하므로 주입받기(생성자를 통해) → `JdbcTemplate`생성자에 전달 ⇒ 스프링에서 권장하는 방법
    - 생성자가 딱 하나있을 때, `@Autowired` 생략할 수 있음.
    
    ```java
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    public JdbcTemplateMemberRepository(DataSource dataSource) {
    	this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
    ```
    
- `findById()` 작성해보기
    - 이전보다 코드 길이가 훨씬 줄어든 것을 볼 수 있음.

```java
@Override
public Optional<Member> findById(Long id) {
    // 나오는 결과를 RowMapper라는 것으로 매핑해줘야 함.
    List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
    return result.stream().findAny();
}

private RowMapper<Member> memberRowMapper() {
		return (rs, rowNum) -> {
				Member member = new Member();
        member.setId(rs.getLong("id"));
        member.setName(rs.getString("name"));
        return member;
    };
}
```

- `save()` 기능
    - `SimpleJdbcInsert` : `withTableName()` 과 `usingGeneratedKeyColumns` 를 사용하면 쿼리를 짤 필요가 없어짐.
    - 그 다음 두 줄까지 하게 되면 insert 문이 만들어짐.
    - 그 다음에 `key`를 받고 이걸 가지고 `member.setId()`를 통해 넣어줄 수 있음.
    - 이렇게 하는구나~ 정도만 알아두면 됨.

```java
public Member save(Member member) {
    SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
    jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

    Map<String, Object> parameters = new HashMap<>();
    parameters.put("name", member.getName());

    Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
    member.setId(key.longValue());
        
    return member;
}
```

**JdbcTemplate을 사용하도록 스프링 설정 변경**

- `SpringConfig.java` 파일 변경

```java
public MemberRepository memberRepository(){
        //return new MemoryMemberRepository();
        //return new JdbcMemberRepository(dataSource);
        return new JdbcTemplateMemberRepository(dataSource);
    }
```

- Test 실행해서 확인 가능
